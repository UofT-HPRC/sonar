################################################################################
# Sonar Configuration File
################################################################################

# Optional Meta Data #
Company: 
Engineer: 
Project_Name: 
Target_Devices: 
Tool_Versions: 
Description: 
Dependencies: 

# Required Data #
Module_Name: top_sim
Timescale: 1ns / 1ps #the default timescale of the simulation
Time_Format: {unit: "1us", precision: 3} #can be one of s, ms, us, ns, ps, fs
Flag_Count: 4 #even if not using, must be non zero for now
################################################################################

# This defines the DUT. The type:clock must be specified only on clocks that the
# the testbench must generate. Size is assumed to be 1 if omitted for signals. 
# All directions are relative to the DUT.
#
# For interfaces, the default is defined in its interface file. Here, AXI-S 
# assumes that its name in Verilog is name_channelName (e.g. axis_output_TDATA).
# c_struct and c_stream are tags needed for C++ to identify the name of the 
# struct variable that is used to read/write data and the struct used to define 
# the stream (i.e. what channels exist) respectively. These names can be seen in
# sample.hpp. If C sim is not required, they can be omitted.
DUT:
  - {direction: input, name: clk, type: clock, period: 20ns}
  - {direction: input, name: mem_sys_clk_p, type: clock, period: 5ns}
  - {direction: input, name: sys_resetn, type: reset}
  - {direction: master, name: stream_out, type: axis, clock: ap_clk, channels: [
      {name: "data", type: "tdata", size: 64},
      {name: "keep", type: "tkeep"},
      {name: "valid", type: "tvalid"},
      {name: "ready", type: "tready"},
      {name: "last", type: "tlast"}
    ]}
  - {direction: slave, name: stream_in, type: axis, clock: ap_clk, channels: [
      {name: "data", type: "tdata", size: 64},
      {name: "keep", type: "tkeep"},
      {name: "valid", type: "tvalid"},
      {name: "ready", type: "tready"},
      {name: "last", type: "tlast"}
    ]}
  - {direction: output, name: mem_ready}

# This defines the test vectors. There may be one or more test vectors with each
# test vector made up of one or more parallel sections. Each parallel section 
# occurs, as the name suggests, in parallel and independently during the 
# testbench. Here, YAML syntax for referencing is used with & and *. 
#
# Fields may also make use of syntax like "{AMHeader,0xAA,0xCC,0,0xE,1,2}" where
# python will concatenate and bitshift an integer for you using the first string 
# as the type. Refer to include/strToInt.py for more information
# 
# Interface payloads can make use of loops that can be nested to send packets.
Initialize: &Initialize
  - wait: {key: clk} # enforce changing signals at negative edge of clocks
  - macro: INIT_SIGNALS # initialize all input signals to zero at t=0
  - delay: 40ns # all delays are multiples of 20ns (clock period) for negedge
  - signal: # set the following signals to the specified values
    - {name: sys_resetn, value: 1}
    
#ETHER DEST: 0xFA163E55CA02
#ETHER SOURCE: 0xFA163E55CA01
#KERNEL DST SOURCE: 0x01
   
#ethernet_wait_header_TRANS_0: &ethernet_wait_header_TRANS_0
#  - wait: {key: "stream_in_ethernet_wait_header_0_TRANS_0", value: "64'h16fa01ca553e16fa"} 
#  - wait: {key: "stream_in_ethernet_wait_header_1_TRANS_0", value: "64'h0000007401ca553e"} 
#
#
#
#ethernet_send_header_TRANS_0: &ethernet_send_header_TRANS_0
#  - interface: {type: axis, name: stream_in, payload: [
#        {tdata: "0x16fa02ca553e16fa", tkeep: "KEEP_ALL"}
#    ]}
#  - interface: {type: axis, name: stream_in, payload: [
#      {tdata: "0x0001007402ca553e", tkeep: "KEEP_ALL"} 
#    ]}
#
##DATA = {8'd1, 8'tag, 24'size, 8'packet_type, 8'src_rank, 8'dst_rank
#mpi_send_header_TRANS_0: &mpi_send_header_TRANS_0
#  - *ethernet_send_header_TRANS_0 
#  - interface: {type: axis, name: stream_in, payload: [
#    {tdata: "0x0100000002000001", tkeep: "KEEP_ALL"} 
#    ]}
#  - *ethernet_wait_header_TRANS_0
#  - wait: {key: "stream_in_mpi_wait_header_TRANS_0", value: "0x010001"} 
#  - *ethernet_send_header_TRANS_0 
#  - interface: {type: axis, name: stream_in, payload: [
#    {tdata: "0x0100000008020001", tkeep: "KEEP_ALL", tlast: 1} 
#    ]}
#    
#ethernet_wait_done_TRANS_0: &ethernet_wait_done_TRANS_0
#    - wait: {key: "stream_in_ethernet_wait_done_header_0_TRANS_0", value: "64'h16fa01ca553e16fa"} 
#    - wait: {key: "stream_in_ethernet_wait_done_header_1_TRANS_0", value: "64'h16fa01ca553e16fa"} 
#
#mpi_wait_done_TRANS_0: &mpi_wait_done_TRANS_0
#    - *ethernet_wait_done_TRANS_0
#    - wait: {key: "stream_in_mpi_wait_done_header_TRANS_0", value: "0x050001"} 
#
#

# This is one test vector that is defined. Whether it gets run is determined by 
# enabling it below under Test_Vectors.
TRANS_0: &TRANS_0
  - Parallel_Section_0: *Initialize
  - Parallel_Section_1:
    - wait: {key: "mem_ready"}   
    - timestamp: TRANS_0 # INIT sets a reference point to compare time to
    # Ethernet send header
    - interface: {type: axis, name: stream_in, payload: [
          {tdata: "0x16fa02ca553e16fa", tkeep: "KEEP_ALL"}
      ]}
    - interface: {type: axis, name: stream_in, payload: [
        {tdata: "0x0001007402ca553e", tkeep: "KEEP_ALL"} 
      ]}
    #mpi send header
    - interface: {type: axis, name: stream_in, payload: [
      {tdata: "0x0100000002000001", tkeep: "KEEP_ALL"} 
      ]}
    #ethernet wait header
    - wait: {key: "stream_in_ethernet_wait_header_0_TRANS_0", value: "0x16fa01ca553e16fa"} 
    - wait: {key: "stream_in_ethernet_wait_header_1_TRANS_0", value: "0x0000007401ca553e"} 
    #mpi wait clear to send  
    - wait: {key: "stream_in_mpi_wait_header_TRANS_0", value: "0x010001"} 
    # Ethernet send header
    - interface: {type: axis, name: stream_in, payload: [
          {tdata: "0x16fa02ca553e16fa", tkeep: "KEEP_ALL"}
      ]}
    - interface: {type: axis, name: stream_in, payload: [
        {tdata: "0x0001007402ca553e", tkeep: "KEEP_ALL"} 
      ]}
    #mpi send data header
    - interface: {type: axis, name: stream_in, payload: [
      {tdata: "0x0100000008020001", tkeep: "KEEP_ALL", tlast: 1} 
      ]}
    # data transaction
    - interface: {type: axis, name: stream_in, payload: [
      {tdata: "0x4100000000000000", tkeep: "KEEP_ALL", tlast: 1} 
      ]}
    # wait for done ethernet header
    - wait: {key: "stream_in_ethernet_wait_done_header_0_TRANS_0", value: "0x16fa01ca553e16fa"} 
    - wait: {key: "stream_in_ethernet_wait_done_header_1_TRANS_0", value: "0x16fa01ca553e16fa"} 
    # wait for done mpi
    - wait: {key: "stream_in_mpi_wait_done_header_TRANS_0", value: "0x050001"} 
    

# These wait conditions are inserted directly into the systemverilog testbench
# and so must be valid syntax (minus any variable substitutions.) Variables may 
# be $value (referring to the value key in a wait packet). For now, only a 
# single argument can be passed to the wait. To use the wait, use the key in the 
# test vector to identify which wait condition to use.
#
# If you use signals in the wait, their names should match the names defined
# above.
Wait_Conditions:
  - {condition: "wait(mem_ready);", key: "mem_ready"}
  - {condition: "wait(stream_in_data == $value && stream_in_valid && stream_in_ready);", key: "stream_in_ethernet_wait_header_0_TRANS_0"}
  - {condition: "wait(stream_in_data == $value && stream_in_valid && stream_in_ready);", key: "stream_in_ethernet_wait_header_1_TRANS_0"}
  - {condition: "wait(stream_in_data[23:0] == $value && stream_in_valid && stream_in_ready);", key: "stream_in_mpi_wait_header_TRANS_0"}
  - {condition: "wait(stream_in_data == $value && stream_in_valid && stream_in_ready);", key: "stream_in_ethernet_wait_done_header_0_TRANS_0"}
  - {condition: "wait(stream_in_data == $value && stream_in_valid && stream_in_ready);", key: "stream_in_ethernet_wait_done_header_1_TRANS_0"}
  - {condition: "wait(stream_in_data[23:0] == $value && stream_in_valid && stream_in_ready);", key: "stream_in_mpi_wait_done_header_TRANS_0"}

# A list of all the test vectors that are actually called, which can be defined 
# above and referenced here. Alternatively, they could all be listed here. 
# Test_Vector_x starts at 0 and goes up to n.
Test_Vectors:
  - Test_Vector_0: *TRANS_0
